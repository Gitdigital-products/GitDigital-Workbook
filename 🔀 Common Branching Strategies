
1. Git Flow (Traditional)

```
main (production)
  â†“
develop (integration)
  â†“
feature/* (new features)
  â†“
release/* (preparing release)
  â†“
hotfix/* (urgent fixes)
```

Commands:

```bash
# Feature branches
git checkout -b feature/user-auth develop
# Work on feature...
git checkout develop
git merge --no-ff feature/user-auth
git branch -d feature/user-auth
```

2. GitHub Flow (Simpler)

Â· main branch is always deployable
Â· Create feature branches from main
Â· Open Pull Requests
Â· Merge after review
Â· Deploy immediately

3. Trunk-Based Development (Modern)

Â· Short-lived feature branches
Â· Frequent commits to main
Â· Feature flags for incomplete work

ğŸ¤ Merging Strategies

Fast-Forward Merge

```bash
# Linear history (preferred when possible)
git checkout main
git merge feature-x
# Deletes feature branch if no longer needed
git branch -d feature-x
```

Three-Way Merge (Merge Commit)

```bash
# Preserves branch history
git checkout main
git merge --no-ff feature-x
# Creates merge commit
```

Rebasing (Clean History)

```bash
# Update feature branch with main
git checkout feature-x
git rebase main

# Interactive rebase (rewrite history)
git rebase -i HEAD~3  # Last 3 commits
```

ğŸš§ Merge Conflicts

Handling Conflicts

```bash
# When conflict occurs during merge/rebase
# Git will mark conflicted files
<<<<<<< HEAD
Current branch changes
=======
Incoming changes
>>>>>>> branch-name

# Resolve by editing files, then:
git add resolved-file.txt
git rebase --continue  # or git merge --continue

# Abort if needed
git rebase --abort
git merge --abort
```

Conflict Resolution Tools

```bash
# Use mergetool
git mergetool

# Configure VS Code as mergetool
git config --global merge.tool vscode
git config --global mergetool.vscode.cmd 'code --wait $MERGED'
```

ğŸ¯ Hands-on Exercises

Exercise 1: Branch Operations

```bash
# Create and switch to new branch
git checkout -b exercise-1

# Make changes
echo "# Exercise 1" > exercise.md
git add exercise.md
git commit -m "Add exercise file"

# Switch back to main
git checkout main

# View branch difference
git diff main..exercise-1
```

Exercise 2: Merge Practice

```bash
# Create two branches with different changes
git checkout -b feature-a
echo "Feature A" > file.txt
git add file.txt
git commit -m "Add feature A"

git checkout main
git checkout -b feature-b
echo "Feature B" > file.txt
git add file.txt
git commit -m "Add feature B"

# Merge feature-a to main
git checkout main
git merge feature-a

# Try merging feature-b (will conflict)
git merge feature-b
# Resolve conflict and complete merge
```

Exercise 3: Rebasing Practice

```bash
# Create feature branch
git checkout -b rebase-exercise

# Make several commits
for i in {1..3}; do
  echo "Commit $i" >> rebase-file.txt
  git add rebase-file.txt
  git commit -m "Add commit $i"
done

# Switch to main and make a change
git checkout main
echo "Main update" > main-file.txt
git add main-file.txt
git commit -m "Update main"

# Rebase feature onto updated main
git checkout rebase-exercise
git rebase main
```

ğŸ“Š Branch Management Best Practices

Naming Conventions

```
feature/user-authentication  # New features
bugfix/login-error           # Bug fixes
hotfix/security-patch        # Urgent fixes
release/v1.2.0              # Release preparation
docs/api-reference          # Documentation
refactor/database-layer     # Code refactoring
```

Cleanup Commands

```bash
# Delete merged branches
git branch --merged main | grep -v "^\*" | xargs -n 1 git branch -d

# Delete remote branches
git push origin --delete old-branch

# Prune remote tracking branches
git fetch --prune
```

ğŸ— Real-World Scenario: Feature Development

```bash
# Start new feature
git checkout main
git pull origin main
git checkout -b feature/new-dashboard

# Daily work
# Make changes...
git add .
git commit -m "Add dashboard components"

# Keep feature updated
git fetch origin
git rebase origin/main

# Ready for review
git push origin feature/new-dashboard
# Create Pull Request on GitHub

# After approval
git checkout main
git pull origin main
git merge --no-ff feature/new-dashboard
git push origin main
git branch -d feature/new-dashboard
```

ğŸ“ Practice Project

Task: Implement a branching strategy for a team project

1. Create a repository with initial structure
2. Set up protected main branch
3. Create develop branch
4. Implement features using feature branches:
   Â· feature/add-login
   Â· feature/user-profile
   Â· feature/admin-panel
5. Create a release/v1.0.0 branch
6. Merge to main with proper tagging

ğŸ“š Cheat Sheet

```bash
# Branch Operations
git branch                      # List branches
git branch -m old-name new-name # Rename branch
git branch -d branch-name       # Delete branch (merged)
git branch -D branch-name       # Force delete (unmerged)

# Remote Branches
git push origin branch-name     # Push branch to remote
git fetch origin                # Get remote branches
git checkout -t origin/branch   # Track remote branch

# Stashing (save uncommitted work)
git stash                      # Save changes
git stash list                 # List stashes
git stash pop                  # Apply and remove stash
git stash apply stash@{0}      # Apply specific stash
```

âš ï¸ Common Pitfalls

1. Long-lived branches - Keep them short and focused
2. Merge without testing - Always test before merging
3. Force push on shared branches - Avoid git push --force
4. Ignoring conflicts - Resolve conflicts immediately